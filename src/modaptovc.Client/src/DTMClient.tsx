//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class DTMClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:8080";
    }

    /**
     * Forward call to Digital Twin
     * @return OK
     */
    proxy(moduleId: string): Promise<any> {
        let url_ = this.baseUrl + "/digital-twins/{moduleId}/**";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProxy(_response);
        });
    }

    protected processProxy(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Get module by ID
     * @return Success
     */
    getModule(moduleId: string): Promise<ModuleResponse> {
        let url_ = this.baseUrl + "/modules/{moduleId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetModule(_response);
        });
    }

    protected processGetModule(response: Response): Promise<ModuleResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Module not found", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
                return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ModuleResponse;
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleResponse>(null as any);
    }

    /**
     * Update an existing module
     * @return Module updated successfully
     */
    updateModule(moduleId: string, body: ModuleRequest): Promise<ModuleResponse> {
        let url_ = this.baseUrl + "/modules/{moduleId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateModule(_response);
        });
    }

    protected processUpdateModule(response: Response): Promise<ModuleResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Module not found", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
                return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ModuleResponse;
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleResponse>(null as any);
    }

    /**
     * Delete a module
     * @return Module deleted successfully
     */
    deleteModule(moduleId: string): Promise<void> {
        let url_ = this.baseUrl + "/modules/{moduleId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteModule(_response);
        });
    }

    protected processDeleteModule(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Module not found", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
                return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get all modules
     * @return Success
     */
    getAllModules(): Promise<ModuleResponse[]> {
        let url_ = this.baseUrl + "/modules";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllModules(_response);
        });
    }

    protected processGetAllModules(response: Response): Promise<ModuleResponse[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 500) {
            return response.text().then((_responseText) => {
                return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ModuleResponse[];
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleResponse[]>(null as any);
    }

    /**
     * Create a new module
     * @return Module created successfully
     */
    createModule(body: ModuleRequest): Promise<ModuleResponse> {
        let url_ = this.baseUrl + "/modules";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateModule(_response);
        });
    }

    protected processCreateModule(response: Response): Promise<ModuleResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
                let result201: any = null;
                result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ModuleResponse;
                return result201;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
                return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleResponse>(null as any);
    }

    /**
     * Get services for a module
     * @return Success
     */
    getServicesForModule(moduleId: string): Promise<SmartServiceResponse[]> {
        let url_ = this.baseUrl + "/modules/{moduleId}/services";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetServicesForModule(_response);
        });
    }

    protected processGetServicesForModule(response: Response): Promise<SmartServiceResponse[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Module not found", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
                return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SmartServiceResponse[];
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SmartServiceResponse[]>(null as any);
    }

    /**
     * Create a new smart service
     * @return Smart Service created successfully
     */
    createService(moduleId: string, body: SmartServiceRequest): Promise<SmartServiceResponse> {
        let url_ = this.baseUrl + "/modules/{moduleId}/services";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateService(_response);
        });
    }

    protected processCreateService(response: Response): Promise<SmartServiceResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Module not found", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
                return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
                let result201: any = null;
                result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SmartServiceResponse;
                return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SmartServiceResponse>(null as any);
    }

    /**
     * Get all smart services
     * @return Success
     */
    getAllSmartServices(): Promise<SmartServiceResponse[]> {
        let url_ = this.baseUrl + "/services";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllSmartServices(_response);
        });
    }

    protected processGetAllSmartServices(response: Response): Promise<SmartServiceResponse[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 500) {
            return response.text().then((_responseText) => {
                return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SmartServiceResponse[];
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SmartServiceResponse[]>(null as any);
    }

    /**
     * Get smart service by ID
     * @return Success
     */
    getSmartService(serviceId: string): Promise<SmartServiceResponse> {
        let url_ = this.baseUrl + "/services/{serviceId}";
        if (serviceId === undefined || serviceId === null)
            throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSmartService(_response);
        });
    }

    protected processGetSmartService(response: Response): Promise<SmartServiceResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Smart Service not found", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
                return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SmartServiceResponse;
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SmartServiceResponse>(null as any);
    }

    /**
     * Delete a smart service
     * @return Smart Service deleted successfully
     */
    deleteSmartService(serviceId: string): Promise<void> {
        let url_ = this.baseUrl + "/services/{serviceId}";
        if (serviceId === undefined || serviceId === null)
            throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSmartService(_response);
        });
    }

    protected processDeleteSmartService(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Smart Service not found", status, _responseText, _headers);
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
                return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get module details by ID
     * @return Success
     */
    getModuleDetails(moduleId: string): Promise<ModuleDetailsResponse> {
        let url_ = this.baseUrl + "/modules/{moduleId}/details";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetModuleDetails(_response);
        });
    }

    protected processGetModuleDetails(response: Response): Promise<ModuleDetailsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Module not found", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
                return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ModuleDetailsResponse;
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleDetailsResponse>(null as any);
    }

    /**
     * Delete a service from a module
     * @return Smart Service deleted from module successfully
     */
    deleteServiceFromModule(moduleId: string, serviceId: string): Promise<void> {
        let url_ = this.baseUrl + "/modules/{moduleId}/services/{serviceId}";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (serviceId === undefined || serviceId === null)
            throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteServiceFromModule(_response);
        });
    }

    protected processDeleteServiceFromModule(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Module or Smart Service not found", status, _responseText, _headers);
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
                return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ProxyDTMClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:8080";
    }

    /**
     * Forward call to Digital Twin
     * @return OK
     */
    3(moduleId: string): Promise<any> {
        let url_ = this.baseUrl + "/digital-twins/{moduleId}/**";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process3(_response);
        });
    }

    protected process3(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Forward call to Digital Twin
     * @return OK
     */
    2(moduleId: string): Promise<any> {
        let url_ = this.baseUrl + "/digital-twins/{moduleId}/**";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process2(_response);
        });
    }

    protected process2(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Forward call to Digital Twin
     * @return OK
     */
    4(moduleId: string): Promise<any> {
        let url_ = this.baseUrl + "/digital-twins/{moduleId}/**";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process4(_response);
        });
    }

    protected process4(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Forward call to Digital Twin
     * @return OK
     */
    1(moduleId: string): Promise<any> {
        let url_ = this.baseUrl + "/digital-twins/{moduleId}/**";
        if (moduleId === undefined || moduleId === null)
            throw new Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "HEAD",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }
}

export interface AssetConnectionConfig {
    operationProviders?: { [key: string]: AssetOperationProviderConfig; };
    subscriptionProviders?: { [key: string]: AssetSubscriptionProviderConfig; };
    valueProviders?: { [key: string]: AssetValueProviderConfig; };

    [key: string]: any;
}

export interface AssetOperationProviderConfig {
    inoutputValidationMode?: AssetOperationProviderConfigInoutputValidationMode;
    outputValidationMode?: AssetOperationProviderConfigOutputValidationMode;
    inputValidationMode?: AssetOperationProviderConfigInputValidationMode;

    [key: string]: any;
}

export interface AssetSubscriptionProviderConfig {

    [key: string]: any;
}

export interface AssetValueProviderConfig {

    [key: string]: any;
}

export interface ModuleRequest {
    /** base64-encoded */
    aas: string;
    format?: ModuleRequestFormat;
    type?: ModuleRequestType;
    assetConnections?: AssetConnectionConfig[];

    [key: string]: any;
}

/** Allows to specifiy how to handle certain output parameters, e.g., to be returned to the user or write value to another property of the DT. */
export interface ArgumentMapping {
    type?: ArgumentMappingType;
    /** When type == CONSTANT this contains the constant value, when typpe == REFERENCE this contains the string serialized reference to the reference AAS element, e.g. (Submodel)http://example.com/submodels/1, (Property)my_referenced_property and for type == USER this property is ignored. */
    value?: string;

    [key: string]: any;
}

export interface DataSpecificationContent {

    [key: string]: any;
}

export interface EmbeddedDataSpecification {
    dataSpecification?: Reference;
    dataSpecificationContent?: DataSpecificationContent;

    [key: string]: any;
}

export interface Extension {
    name?: string;
    value?: string;
    valueType?: ExtensionValueType;
    refersTo?: Reference[];
    supplementalSemanticIds?: Reference[];
    semanticId?: Reference;

    [key: string]: any;
}

export interface Key {
    value?: string;
    type?: KeyType;

    [key: string]: any;
}

export interface LangStringNameType {
    language?: string;
    text?: string;

    [key: string]: any;
}

export interface LangStringTextType {
    language?: string;
    text?: string;

    [key: string]: any;
}

export interface ModuleResponse {
    id?: string;
    endpoint?: string;
    services?: SmartServiceResponse[];

    [key: string]: any;
}

export interface Qualifier {
    value?: string;
    type?: string;
    kind?: QualifierKind;
    valueType?: QualifierValueType;
    valueId?: Reference;
    supplementalSemanticIds?: Reference[];
    semanticId?: Reference;

    [key: string]: any;
}

export interface Reference {
    type?: ReferenceType;
    keys?: Key[];
    referredSemanticId?: Reference;

    [key: string]: any;
}

export interface SmartServiceResponse {
    id?: string;
    serviceCatalogId?: string;
    endpoint?: string;
    name?: string;
    description?: string;
    /** Allows to specifiy how to handle certain input parameters, e.g., have to be provided by the user upon invocation, use constant values, or fetch value from another property of the DT. */
    inputArgumentTypes?: { [key: string]: ArgumentMapping; };
    /** Allows to specifiy how to handle certain output parameters, e.g., to be returned to the user or write value to another property of the DT. */
    outputArgumentTypes?: { [key: string]: ArgumentMapping; };
    /** Input parameters that have to be provided by the user upon invocation. */
    actualInputParameters?: SubmodelElement[];
    /** Output parameters that will be returned to the user after invocation. */
    actualOutputParameters?: SubmodelElement[];

    [key: string]: any;
}

/** Output parameters that will be returned to the user after invocation. */
export interface SubmodelElement {
    embeddedDataSpecifications?: EmbeddedDataSpecification[];
    displayName?: LangStringNameType[];
    description?: LangStringTextType[];
    idShort?: string;
    category?: string;
    extensions?: Extension[];
    supplementalSemanticIds?: Reference[];
    semanticId?: Reference;
    qualifiers?: Qualifier[];

    [key: string]: any;
}

export interface SmartServiceRequest {
    serviceCatalogId: string;
    name: string;
    description?: string;
    inputParameters?: SubmodelElement[];
    outputParameters?: SubmodelElement[];
    /** Allows to change input arguments source from user to constant value or to be fetched from another AAS element */
    inputArgumentTypes?: { [key: string]: ArgumentMapping; };
    /** Allows to change output arguments source from user to constant value or to be written to another AAS element */
    outputArgumentTypes?: { [key: string]: ArgumentMapping; };

    [key: string]: any;
}

export interface ModuleDetailsResponse {
    /** base64-encoded */
    providedModel?: string;
    /** base64-encoded */
    actualModel?: string;

    [key: string]: any;
}

export enum AssetOperationProviderConfigInoutputValidationMode {
    NONE = "NONE",
    REQUIRE_PRESENT = "REQUIRE_PRESENT",
    REQUIRE_PRESENT_OR_DEFAULT = "REQUIRE_PRESENT_OR_DEFAULT",
}

export enum AssetOperationProviderConfigOutputValidationMode {
    NONE = "NONE",
    REQUIRE_PRESENT = "REQUIRE_PRESENT",
    REQUIRE_PRESENT_OR_DEFAULT = "REQUIRE_PRESENT_OR_DEFAULT",
}

export enum AssetOperationProviderConfigInputValidationMode {
    NONE = "NONE",
    REQUIRE_PRESENT = "REQUIRE_PRESENT",
    REQUIRE_PRESENT_OR_DEFAULT = "REQUIRE_PRESENT_OR_DEFAULT",
}

export enum ModuleRequestFormat {
    JSON = "JSON",
    XML = "XML",
    RDF = "RDF",
    JSONLD = "JSONLD",
    AASX = "AASX",
}

export enum ModuleRequestType {
    DOCKER = "DOCKER",
    INTERNAL = "INTERNAL",
}

export enum ArgumentMappingType {
    CONSTANT = "CONSTANT",
    USER = "USER",
    REFERENCE = "REFERENCE",
}

export enum ExtensionValueType {
    ANY_URI = "ANY_URI",
    BASE64BINARY = "BASE64BINARY",
    BOOLEAN = "BOOLEAN",
    BYTE = "BYTE",
    DATE = "DATE",
    DATE_TIME = "DATE_TIME",
    DECIMAL = "DECIMAL",
    DOUBLE = "DOUBLE",
    DURATION = "DURATION",
    FLOAT = "FLOAT",
    GDAY = "GDAY",
    GMONTH = "GMONTH",
    GMONTH_DAY = "GMONTH_DAY",
    GYEAR = "GYEAR",
    GYEAR_MONTH = "GYEAR_MONTH",
    HEX_BINARY = "HEX_BINARY",
    INT = "INT",
    INTEGER = "INTEGER",
    LONG = "LONG",
    NEGATIVE_INTEGER = "NEGATIVE_INTEGER",
    NON_NEGATIVE_INTEGER = "NON_NEGATIVE_INTEGER",
    NON_POSITIVE_INTEGER = "NON_POSITIVE_INTEGER",
    POSITIVE_INTEGER = "POSITIVE_INTEGER",
    SHORT = "SHORT",
    STRING = "STRING",
    TIME = "TIME",
    UNSIGNED_BYTE = "UNSIGNED_BYTE",
    UNSIGNED_INT = "UNSIGNED_INT",
    UNSIGNED_LONG = "UNSIGNED_LONG",
    UNSIGNED_SHORT = "UNSIGNED_SHORT",
}

export enum KeyType {
    ANNOTATED_RELATIONSHIP_ELEMENT = "ANNOTATED_RELATIONSHIP_ELEMENT",
    ASSET_ADMINISTRATION_SHELL = "ASSET_ADMINISTRATION_SHELL",
    BASIC_EVENT_ELEMENT = "BASIC_EVENT_ELEMENT",
    BLOB = "BLOB",
    CAPABILITY = "CAPABILITY",
    CONCEPT_DESCRIPTION = "CONCEPT_DESCRIPTION",
    DATA_ELEMENT = "DATA_ELEMENT",
    ENTITY = "ENTITY",
    EVENT_ELEMENT = "EVENT_ELEMENT",
    FILE = "FILE",
    FRAGMENT_REFERENCE = "FRAGMENT_REFERENCE",
    GLOBAL_REFERENCE = "GLOBAL_REFERENCE",
    IDENTIFIABLE = "IDENTIFIABLE",
    MULTI_LANGUAGE_PROPERTY = "MULTI_LANGUAGE_PROPERTY",
    OPERATION = "OPERATION",
    PROPERTY = "PROPERTY",
    RANGE = "RANGE",
    REFERABLE = "REFERABLE",
    REFERENCE_ELEMENT = "REFERENCE_ELEMENT",
    RELATIONSHIP_ELEMENT = "RELATIONSHIP_ELEMENT",
    SUBMODEL = "SUBMODEL",
    SUBMODEL_ELEMENT = "SUBMODEL_ELEMENT",
    SUBMODEL_ELEMENT_COLLECTION = "SUBMODEL_ELEMENT_COLLECTION",
    SUBMODEL_ELEMENT_LIST = "SUBMODEL_ELEMENT_LIST",
}

export enum QualifierKind {
    CONCEPT_QUALIFIER = "CONCEPT_QUALIFIER",
    TEMPLATE_QUALIFIER = "TEMPLATE_QUALIFIER",
    VALUE_QUALIFIER = "VALUE_QUALIFIER",
}

export enum QualifierValueType {
    ANY_URI = "ANY_URI",
    BASE64BINARY = "BASE64BINARY",
    BOOLEAN = "BOOLEAN",
    BYTE = "BYTE",
    DATE = "DATE",
    DATE_TIME = "DATE_TIME",
    DECIMAL = "DECIMAL",
    DOUBLE = "DOUBLE",
    DURATION = "DURATION",
    FLOAT = "FLOAT",
    GDAY = "GDAY",
    GMONTH = "GMONTH",
    GMONTH_DAY = "GMONTH_DAY",
    GYEAR = "GYEAR",
    GYEAR_MONTH = "GYEAR_MONTH",
    HEX_BINARY = "HEX_BINARY",
    INT = "INT",
    INTEGER = "INTEGER",
    LONG = "LONG",
    NEGATIVE_INTEGER = "NEGATIVE_INTEGER",
    NON_NEGATIVE_INTEGER = "NON_NEGATIVE_INTEGER",
    NON_POSITIVE_INTEGER = "NON_POSITIVE_INTEGER",
    POSITIVE_INTEGER = "POSITIVE_INTEGER",
    SHORT = "SHORT",
    STRING = "STRING",
    TIME = "TIME",
    UNSIGNED_BYTE = "UNSIGNED_BYTE",
    UNSIGNED_INT = "UNSIGNED_INT",
    UNSIGNED_LONG = "UNSIGNED_LONG",
    UNSIGNED_SHORT = "UNSIGNED_SHORT",
}

export enum ReferenceType {
    EXTERNAL_REFERENCE = "EXTERNAL_REFERENCE",
    MODEL_REFERENCE = "MODEL_REFERENCE",
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}