//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.1.0 (NJsonSchema v11.5.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

export class DTMClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:8080";
    }

    /**
     * Forward call to Digital Twin
     * @return OK
     */
    proxy(moduleId: string): Promise<any> {
        let url_ = this.baseUrl + "/digital-twins/{moduleId}/**";
        if (moduleId === undefined || moduleId === null)
            throw new globalThis.Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProxy(_response);
        });
    }

    protected processProxy(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;

                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Forward call to Digital Twin
     * @return OK
     */
    proxy_3(moduleId: string): Promise<any> {
        let url_ = this.baseUrl + "/digital-twins/{moduleId}/**";
        if (moduleId === undefined || moduleId === null)
            throw new globalThis.Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProxy_3(_response);
        });
    }

    protected processProxy_3(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;

                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Forward call to Digital Twin
     * @return OK
     */
    proxy_2(moduleId: string): Promise<any> {
        let url_ = this.baseUrl + "/digital-twins/{moduleId}/**";
        if (moduleId === undefined || moduleId === null)
            throw new globalThis.Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProxy_2(_response);
        });
    }

    protected processProxy_2(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;

                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Forward call to Digital Twin
     * @return OK
     */
    proxy_4(moduleId: string): Promise<any> {
        let url_ = this.baseUrl + "/digital-twins/{moduleId}/**";
        if (moduleId === undefined || moduleId === null)
            throw new globalThis.Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProxy_4(_response);
        });
    }

    protected processProxy_4(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;

                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Forward call to Digital Twin
     * @return OK
     */
    proxy_1(moduleId: string): Promise<any> {
        let url_ = this.baseUrl + "/digital-twins/{moduleId}/**";
        if (moduleId === undefined || moduleId === null)
            throw new globalThis.Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "HEAD",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProxy_1(_response);
        });
    }

    protected processProxy_1(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;

                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Get module by ID
     * @return Success
     */
    getModule(moduleId: string): Promise<ModuleResponse> {
        let url_ = this.baseUrl + "/modules/{moduleId}";
        if (moduleId === undefined || moduleId === null)
            throw new globalThis.Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetModule(_response);
        });
    }

    protected processGetModule(response: Response): Promise<ModuleResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ModuleResponse.fromJS(resultData200);
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Module not found", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
                return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleResponse>(null as any);
    }

    /**
     * Update an existing module
     * @return Module updated successfully
     */
    updateModule(moduleId: string, body: ModuleRequest): Promise<ModuleResponse> {
        let url_ = this.baseUrl + "/modules/{moduleId}";
        if (moduleId === undefined || moduleId === null)
            throw new globalThis.Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateModule(_response);
        });
    }

    protected processUpdateModule(response: Response): Promise<ModuleResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ModuleResponse.fromJS(resultData200);
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Module not found", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
                return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleResponse>(null as any);
    }

    /**
     * Delete a module
     * @return Module deleted successfully
     */
    deleteModule(moduleId: string): Promise<void> {
        let url_ = this.baseUrl + "/modules/{moduleId}";
        if (moduleId === undefined || moduleId === null)
            throw new globalThis.Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteModule(_response);
        });
    }

    protected processDeleteModule(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Module not found", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
                return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get all modules
     * @return Success
     */
    getAllModules(): Promise<ModuleResponse[]> {
        let url_ = this.baseUrl + "/modules";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllModules(_response);
        });
    }

    protected processGetAllModules(response: Response): Promise<ModuleResponse[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(ModuleResponse.fromJS(item));
                }
                else {
                    result200 = null as any;
                }
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
                return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleResponse[]>(null as any);
    }

    /**
     * Create a new module
     * @return Module created successfully
     */
    createModule(body: ModuleRequest): Promise<ModuleResponse> {
        let url_ = this.baseUrl + "/modules";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateModule(_response);
        });
    }

    protected processCreateModule(response: Response): Promise<ModuleResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = ModuleResponse.fromJS(resultData201);
                return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
                return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleResponse>(null as any);
    }

    /**
     * Get services for a module
     * @return Success
     */
    getServicesForModule(moduleId: string): Promise<SmartServiceResponse[]> {
        let url_ = this.baseUrl + "/modules/{moduleId}/services";
        if (moduleId === undefined || moduleId === null)
            throw new globalThis.Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetServicesForModule(_response);
        });
    }

    protected processGetServicesForModule(response: Response): Promise<SmartServiceResponse[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(SmartServiceResponse.fromJS(item));
                }
                else {
                    result200 = null as any;
                }
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Module not found", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
                return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SmartServiceResponse[]>(null as any);
    }

    /**
     * Create a new smart service
     * @return Smart Service created successfully
     */
    createService(moduleId: string, body: SmartServiceRequest): Promise<SmartServiceResponse> {
        let url_ = this.baseUrl + "/modules/{moduleId}/services";
        if (moduleId === undefined || moduleId === null)
            throw new globalThis.Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateService(_response);
        });
    }

    protected processCreateService(response: Response): Promise<SmartServiceResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = SmartServiceResponse.fromJS(resultData201);
                return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Module not found", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
                return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SmartServiceResponse>(null as any);
    }

    /**
     * Get all smart services
     * @return Success
     */
    getAllSmartServices(): Promise<SmartServiceResponse[]> {
        let url_ = this.baseUrl + "/services";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllSmartServices(_response);
        });
    }

    protected processGetAllSmartServices(response: Response): Promise<SmartServiceResponse[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(SmartServiceResponse.fromJS(item));
                }
                else {
                    result200 = null as any;
                }
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
                return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SmartServiceResponse[]>(null as any);
    }

    /**
     * Get smart service by ID
     * @return Success
     */
    getSmartService(serviceId: string): Promise<SmartServiceResponse> {
        let url_ = this.baseUrl + "/services/{serviceId}";
        if (serviceId === undefined || serviceId === null)
            throw new globalThis.Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSmartService(_response);
        });
    }

    protected processGetSmartService(response: Response): Promise<SmartServiceResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = SmartServiceResponse.fromJS(resultData200);
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Smart Service not found", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
                return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SmartServiceResponse>(null as any);
    }

    /**
     * Delete a smart service
     * @return Smart Service deleted successfully
     */
    deleteSmartService(serviceId: string): Promise<void> {
        let url_ = this.baseUrl + "/services/{serviceId}";
        if (serviceId === undefined || serviceId === null)
            throw new globalThis.Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSmartService(_response);
        });
    }

    protected processDeleteSmartService(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Smart Service not found", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
                return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get module details by ID
     * @return Success
     */
    getModuleDetails(moduleId: string): Promise<ModuleDetailsResponse> {
        let url_ = this.baseUrl + "/modules/{moduleId}/details";
        if (moduleId === undefined || moduleId === null)
            throw new globalThis.Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetModuleDetails(_response);
        });
    }

    protected processGetModuleDetails(response: Response): Promise<ModuleDetailsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ModuleDetailsResponse.fromJS(resultData200);
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Module not found", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
                return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleDetailsResponse>(null as any);
    }

    /**
     * Delete a service from a module
     * @return Smart Service deleted from module successfully
     */
    deleteServiceFromModule(moduleId: string, serviceId: string): Promise<void> {
        let url_ = this.baseUrl + "/modules/{moduleId}/services/{serviceId}";
        if (moduleId === undefined || moduleId === null)
            throw new globalThis.Error("The parameter 'moduleId' must be defined.");
        url_ = url_.replace("{moduleId}", encodeURIComponent("" + moduleId));
        if (serviceId === undefined || serviceId === null)
            throw new globalThis.Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteServiceFromModule(_response);
        });
    }

    protected processDeleteServiceFromModule(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("Module or Smart Service not found", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
                return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AssetConnectionConfig implements IAssetConnectionConfig {
    operationProviders?: { [key: string]: AssetOperationProviderConfig; };
    subscriptionProviders?: { [key: string]: AssetSubscriptionProviderConfig; };
    valueProviders?: { [key: string]: AssetValueProviderConfig; };

    [key: string]: any;

    constructor(data?: IAssetConnectionConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["operationProviders"]) {
                this.operationProviders = {} as any;
                for (let key in _data["operationProviders"]) {
                    if (_data["operationProviders"].hasOwnProperty(key))
                        (this.operationProviders as any)![key] = _data["operationProviders"][key] ? AssetOperationProviderConfig.fromJS(_data["operationProviders"][key]) : new AssetOperationProviderConfig();
                }
            }
            if (_data["subscriptionProviders"]) {
                this.subscriptionProviders = {} as any;
                for (let key in _data["subscriptionProviders"]) {
                    if (_data["subscriptionProviders"].hasOwnProperty(key))
                        (this.subscriptionProviders as any)![key] = _data["subscriptionProviders"][key] ? AssetSubscriptionProviderConfig.fromJS(_data["subscriptionProviders"][key]) : new AssetSubscriptionProviderConfig();
                }
            }
            if (_data["valueProviders"]) {
                this.valueProviders = {} as any;
                for (let key in _data["valueProviders"]) {
                    if (_data["valueProviders"].hasOwnProperty(key))
                        (this.valueProviders as any)![key] = _data["valueProviders"][key] ? AssetValueProviderConfig.fromJS(_data["valueProviders"][key]) : new AssetValueProviderConfig();
                }
            }
        }
    }

    static fromJS(data: any): AssetConnectionConfig {
        data = typeof data === 'object' ? data : {};
        let result = new AssetConnectionConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.operationProviders) {
            data["operationProviders"] = {};
            for (let key in this.operationProviders) {
                if (this.operationProviders.hasOwnProperty(key))
                    (data["operationProviders"] as any)[key] = this.operationProviders[key] ? this.operationProviders[key].toJSON() : undefined as any;
            }
        }
        if (this.subscriptionProviders) {
            data["subscriptionProviders"] = {};
            for (let key in this.subscriptionProviders) {
                if (this.subscriptionProviders.hasOwnProperty(key))
                    (data["subscriptionProviders"] as any)[key] = this.subscriptionProviders[key] ? this.subscriptionProviders[key].toJSON() : undefined as any;
            }
        }
        if (this.valueProviders) {
            data["valueProviders"] = {};
            for (let key in this.valueProviders) {
                if (this.valueProviders.hasOwnProperty(key))
                    (data["valueProviders"] as any)[key] = this.valueProviders[key] ? this.valueProviders[key].toJSON() : undefined as any;
            }
        }
        return data;
    }
}

export interface IAssetConnectionConfig {
    operationProviders?: { [key: string]: AssetOperationProviderConfig; };
    subscriptionProviders?: { [key: string]: AssetSubscriptionProviderConfig; };
    valueProviders?: { [key: string]: AssetValueProviderConfig; };

    [key: string]: any;
}

export class AssetOperationProviderConfig implements IAssetOperationProviderConfig {
    inputValidationMode?: AssetOperationProviderConfigInputValidationMode;
    inoutputValidationMode?: AssetOperationProviderConfigInoutputValidationMode;
    outputValidationMode?: AssetOperationProviderConfigOutputValidationMode;

    [key: string]: any;

    constructor(data?: IAssetOperationProviderConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.inputValidationMode = _data["inputValidationMode"];
            this.inoutputValidationMode = _data["inoutputValidationMode"];
            this.outputValidationMode = _data["outputValidationMode"];
        }
    }

    static fromJS(data: any): AssetOperationProviderConfig {
        data = typeof data === 'object' ? data : {};
        let result = new AssetOperationProviderConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["inputValidationMode"] = this.inputValidationMode;
        data["inoutputValidationMode"] = this.inoutputValidationMode;
        data["outputValidationMode"] = this.outputValidationMode;
        return data;
    }
}

export interface IAssetOperationProviderConfig {
    inputValidationMode?: AssetOperationProviderConfigInputValidationMode;
    inoutputValidationMode?: AssetOperationProviderConfigInoutputValidationMode;
    outputValidationMode?: AssetOperationProviderConfigOutputValidationMode;

    [key: string]: any;
}

export class AssetSubscriptionProviderConfig implements IAssetSubscriptionProviderConfig {

    [key: string]: any;

    constructor(data?: IAssetSubscriptionProviderConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): AssetSubscriptionProviderConfig {
        data = typeof data === 'object' ? data : {};
        let result = new AssetSubscriptionProviderConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IAssetSubscriptionProviderConfig {

    [key: string]: any;
}

export class AssetValueProviderConfig implements IAssetValueProviderConfig {

    [key: string]: any;

    constructor(data?: IAssetValueProviderConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): AssetValueProviderConfig {
        data = typeof data === 'object' ? data : {};
        let result = new AssetValueProviderConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IAssetValueProviderConfig {

    [key: string]: any;
}

export class ModuleRequest implements IModuleRequest {
    name?: string;
    /** base64-encoded */
    aas!: string;
    format?: ModuleRequestFormat;
    type?: ModuleRequestType;
    assetConnections?: AssetConnectionConfig[];

    [key: string]: any;

    constructor(data?: IModuleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.format = ModuleRequestFormat.JSON;
            this.type = ModuleRequestType.DOCKER;
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.aas = _data["aas"];
            this.format = _data["format"] !== undefined ? _data["format"] : ModuleRequestFormat.JSON;
            this.type = _data["type"] !== undefined ? _data["type"] : ModuleRequestType.DOCKER;
            if (Array.isArray(_data["assetConnections"])) {
                this.assetConnections = [] as any;
                for (let item of _data["assetConnections"])
                    this.assetConnections!.push(AssetConnectionConfig.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModuleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["aas"] = this.aas;
        data["format"] = this.format;
        data["type"] = this.type;
        if (Array.isArray(this.assetConnections)) {
            data["assetConnections"] = [];
            for (let item of this.assetConnections)
                data["assetConnections"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IModuleRequest {
    name?: string;
    /** base64-encoded */
    aas: string;
    format?: ModuleRequestFormat;
    type?: ModuleRequestType;
    assetConnections?: AssetConnectionConfig[];

    [key: string]: any;
}

/** Allows to specifiy how to handle certain output parameters, e.g., to be returned to the user or write value to another property of the DT. */
export class ArgumentMapping implements IArgumentMapping {
    type?: ArgumentMappingType;
    /** When type == CONSTANT this contains the constant value, when typpe == REFERENCE this contains the string serialized reference to the reference AAS element, e.g. (Submodel)http://example.com/submodels/1, (Property)my_referenced_property and for type == USER this property is ignored. */
    value?: string;

    [key: string]: any;

    constructor(data?: IArgumentMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ArgumentMapping {
        data = typeof data === 'object' ? data : {};
        let result = new ArgumentMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["value"] = this.value;
        return data;
    }
}

/** Allows to specifiy how to handle certain output parameters, e.g., to be returned to the user or write value to another property of the DT. */
export interface IArgumentMapping {
    type?: ArgumentMappingType;
    /** When type == CONSTANT this contains the constant value, when typpe == REFERENCE this contains the string serialized reference to the reference AAS element, e.g. (Submodel)http://example.com/submodels/1, (Property)my_referenced_property and for type == USER this property is ignored. */
    value?: string;

    [key: string]: any;
}

export class DataSpecificationContent implements IDataSpecificationContent {

    [key: string]: any;

    constructor(data?: IDataSpecificationContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): DataSpecificationContent {
        data = typeof data === 'object' ? data : {};
        let result = new DataSpecificationContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IDataSpecificationContent {

    [key: string]: any;
}

export class EmbeddedDataSpecification implements IEmbeddedDataSpecification {
    dataSpecification?: Reference;
    dataSpecificationContent?: DataSpecificationContent;

    [key: string]: any;

    constructor(data?: IEmbeddedDataSpecification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.dataSpecification = _data["dataSpecification"] ? Reference.fromJS(_data["dataSpecification"]) : undefined as any;
            this.dataSpecificationContent = _data["dataSpecificationContent"] ? DataSpecificationContent.fromJS(_data["dataSpecificationContent"]) : undefined as any;
        }
    }

    static fromJS(data: any): EmbeddedDataSpecification {
        data = typeof data === 'object' ? data : {};
        let result = new EmbeddedDataSpecification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["dataSpecification"] = this.dataSpecification ? this.dataSpecification.toJSON() : undefined as any;
        data["dataSpecificationContent"] = this.dataSpecificationContent ? this.dataSpecificationContent.toJSON() : undefined as any;
        return data;
    }
}

export interface IEmbeddedDataSpecification {
    dataSpecification?: Reference;
    dataSpecificationContent?: DataSpecificationContent;

    [key: string]: any;
}

export class Extension implements IExtension {
    name?: string;
    value?: string;
    valueType?: ExtensionValueType;
    refersTo?: Reference[];
    supplementalSemanticIds?: Reference[];
    semanticId?: Reference;

    [key: string]: any;

    constructor(data?: IExtension) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.value = _data["value"];
            this.valueType = _data["valueType"];
            if (Array.isArray(_data["refersTo"])) {
                this.refersTo = [] as any;
                for (let item of _data["refersTo"])
                    this.refersTo!.push(Reference.fromJS(item));
            }
            if (Array.isArray(_data["supplementalSemanticIds"])) {
                this.supplementalSemanticIds = [] as any;
                for (let item of _data["supplementalSemanticIds"])
                    this.supplementalSemanticIds!.push(Reference.fromJS(item));
            }
            this.semanticId = _data["semanticId"] ? Reference.fromJS(_data["semanticId"]) : undefined as any;
        }
    }

    static fromJS(data: any): Extension {
        data = typeof data === 'object' ? data : {};
        let result = new Extension();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["value"] = this.value;
        data["valueType"] = this.valueType;
        if (Array.isArray(this.refersTo)) {
            data["refersTo"] = [];
            for (let item of this.refersTo)
                data["refersTo"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.supplementalSemanticIds)) {
            data["supplementalSemanticIds"] = [];
            for (let item of this.supplementalSemanticIds)
                data["supplementalSemanticIds"].push(item ? item.toJSON() : undefined as any);
        }
        data["semanticId"] = this.semanticId ? this.semanticId.toJSON() : undefined as any;
        return data;
    }
}

export interface IExtension {
    name?: string;
    value?: string;
    valueType?: ExtensionValueType;
    refersTo?: Reference[];
    supplementalSemanticIds?: Reference[];
    semanticId?: Reference;

    [key: string]: any;
}

export class Key implements IKey {
    value?: string;
    type?: KeyType;

    [key: string]: any;

    constructor(data?: IKey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): Key {
        data = typeof data === 'object' ? data : {};
        let result = new Key();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        data["type"] = this.type;
        return data;
    }
}

export interface IKey {
    value?: string;
    type?: KeyType;

    [key: string]: any;
}

export class LangStringNameType implements ILangStringNameType {
    language?: string;
    text?: string;

    [key: string]: any;

    constructor(data?: ILangStringNameType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.language = _data["language"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): LangStringNameType {
        data = typeof data === 'object' ? data : {};
        let result = new LangStringNameType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["language"] = this.language;
        data["text"] = this.text;
        return data;
    }
}

export interface ILangStringNameType {
    language?: string;
    text?: string;

    [key: string]: any;
}

export class LangStringTextType implements ILangStringTextType {
    language?: string;
    text?: string;

    [key: string]: any;

    constructor(data?: ILangStringTextType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.language = _data["language"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): LangStringTextType {
        data = typeof data === 'object' ? data : {};
        let result = new LangStringTextType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["language"] = this.language;
        data["text"] = this.text;
        return data;
    }
}

export interface ILangStringTextType {
    language?: string;
    text?: string;

    [key: string]: any;
}

export class ModuleResponse implements IModuleResponse {
    id?: string;
    name?: string;
    endpoint?: string;
    services?: SmartServiceResponse[];

    [key: string]: any;

    constructor(data?: IModuleResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.endpoint = _data["endpoint"];
            if (Array.isArray(_data["services"])) {
                this.services = [] as any;
                for (let item of _data["services"])
                    this.services!.push(SmartServiceResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModuleResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["endpoint"] = this.endpoint;
        if (Array.isArray(this.services)) {
            data["services"] = [];
            for (let item of this.services)
                data["services"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IModuleResponse {
    id?: string;
    name?: string;
    endpoint?: string;
    services?: SmartServiceResponse[];

    [key: string]: any;
}

export class Qualifier implements IQualifier {
    value?: string;
    type?: string;
    kind?: QualifierKind;
    valueType?: QualifierValueType;
    valueId?: Reference;
    supplementalSemanticIds?: Reference[];
    semanticId?: Reference;

    [key: string]: any;

    constructor(data?: IQualifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
            this.type = _data["type"];
            this.kind = _data["kind"];
            this.valueType = _data["valueType"];
            this.valueId = _data["valueId"] ? Reference.fromJS(_data["valueId"]) : undefined as any;
            if (Array.isArray(_data["supplementalSemanticIds"])) {
                this.supplementalSemanticIds = [] as any;
                for (let item of _data["supplementalSemanticIds"])
                    this.supplementalSemanticIds!.push(Reference.fromJS(item));
            }
            this.semanticId = _data["semanticId"] ? Reference.fromJS(_data["semanticId"]) : undefined as any;
        }
    }

    static fromJS(data: any): Qualifier {
        data = typeof data === 'object' ? data : {};
        let result = new Qualifier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        data["type"] = this.type;
        data["kind"] = this.kind;
        data["valueType"] = this.valueType;
        data["valueId"] = this.valueId ? this.valueId.toJSON() : undefined as any;
        if (Array.isArray(this.supplementalSemanticIds)) {
            data["supplementalSemanticIds"] = [];
            for (let item of this.supplementalSemanticIds)
                data["supplementalSemanticIds"].push(item ? item.toJSON() : undefined as any);
        }
        data["semanticId"] = this.semanticId ? this.semanticId.toJSON() : undefined as any;
        return data;
    }
}

export interface IQualifier {
    value?: string;
    type?: string;
    kind?: QualifierKind;
    valueType?: QualifierValueType;
    valueId?: Reference;
    supplementalSemanticIds?: Reference[];
    semanticId?: Reference;

    [key: string]: any;
}

export class Reference implements IReference {
    type?: ReferenceType;
    keys?: Key[];
    referredSemanticId?: Reference;

    [key: string]: any;

    constructor(data?: IReference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            if (Array.isArray(_data["keys"])) {
                this.keys = [] as any;
                for (let item of _data["keys"])
                    this.keys!.push(Key.fromJS(item));
            }
            this.referredSemanticId = _data["referredSemanticId"] ? Reference.fromJS(_data["referredSemanticId"]) : undefined as any;
        }
    }

    static fromJS(data: any): Reference {
        data = typeof data === 'object' ? data : {};
        let result = new Reference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        if (Array.isArray(this.keys)) {
            data["keys"] = [];
            for (let item of this.keys)
                data["keys"].push(item ? item.toJSON() : undefined as any);
        }
        data["referredSemanticId"] = this.referredSemanticId ? this.referredSemanticId.toJSON() : undefined as any;
        return data;
    }
}

export interface IReference {
    type?: ReferenceType;
    keys?: Key[];
    referredSemanticId?: Reference;

    [key: string]: any;
}

export class SmartServiceResponse implements ISmartServiceResponse {
    id?: string;
    serviceCatalogId?: string;
    endpoint?: string;
    name?: string;
    description?: string;
    /** Allows to specifiy how to handle certain input parameters, e.g., have to be provided by the user upon invocation, use constant values, or fetch value from another property of the DT. */
    inputArgumentTypes?: { [key: string]: ArgumentMapping; };
    /** Allows to specifiy how to handle certain output parameters, e.g., to be returned to the user or write value to another property of the DT. */
    outputArgumentTypes?: { [key: string]: ArgumentMapping; };
    /** Input parameters that have to be provided by the user upon invocation. */
    actualInputParameters?: SubmodelElement[];
    /** Output parameters that will be returned to the user after invocation. */
    actualOutputParameters?: SubmodelElement[];

    [key: string]: any;

    constructor(data?: ISmartServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.serviceCatalogId = _data["serviceCatalogId"];
            this.endpoint = _data["endpoint"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (_data["inputArgumentTypes"]) {
                this.inputArgumentTypes = {} as any;
                for (let key in _data["inputArgumentTypes"]) {
                    if (_data["inputArgumentTypes"].hasOwnProperty(key))
                        (this.inputArgumentTypes as any)![key] = _data["inputArgumentTypes"][key] ? ArgumentMapping.fromJS(_data["inputArgumentTypes"][key]) : new ArgumentMapping();
                }
            }
            if (_data["outputArgumentTypes"]) {
                this.outputArgumentTypes = {} as any;
                for (let key in _data["outputArgumentTypes"]) {
                    if (_data["outputArgumentTypes"].hasOwnProperty(key))
                        (this.outputArgumentTypes as any)![key] = _data["outputArgumentTypes"][key] ? ArgumentMapping.fromJS(_data["outputArgumentTypes"][key]) : new ArgumentMapping();
                }
            }
            if (Array.isArray(_data["actualInputParameters"])) {
                this.actualInputParameters = [] as any;
                for (let item of _data["actualInputParameters"])
                    this.actualInputParameters!.push(SubmodelElement.fromJS(item));
            }
            if (Array.isArray(_data["actualOutputParameters"])) {
                this.actualOutputParameters = [] as any;
                for (let item of _data["actualOutputParameters"])
                    this.actualOutputParameters!.push(SubmodelElement.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SmartServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SmartServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["serviceCatalogId"] = this.serviceCatalogId;
        data["endpoint"] = this.endpoint;
        data["name"] = this.name;
        data["description"] = this.description;
        if (this.inputArgumentTypes) {
            data["inputArgumentTypes"] = {};
            for (let key in this.inputArgumentTypes) {
                if (this.inputArgumentTypes.hasOwnProperty(key))
                    (data["inputArgumentTypes"] as any)[key] = this.inputArgumentTypes[key] ? this.inputArgumentTypes[key].toJSON() : undefined as any;
            }
        }
        if (this.outputArgumentTypes) {
            data["outputArgumentTypes"] = {};
            for (let key in this.outputArgumentTypes) {
                if (this.outputArgumentTypes.hasOwnProperty(key))
                    (data["outputArgumentTypes"] as any)[key] = this.outputArgumentTypes[key] ? this.outputArgumentTypes[key].toJSON() : undefined as any;
            }
        }
        if (Array.isArray(this.actualInputParameters)) {
            data["actualInputParameters"] = [];
            for (let item of this.actualInputParameters)
                data["actualInputParameters"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.actualOutputParameters)) {
            data["actualOutputParameters"] = [];
            for (let item of this.actualOutputParameters)
                data["actualOutputParameters"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ISmartServiceResponse {
    id?: string;
    serviceCatalogId?: string;
    endpoint?: string;
    name?: string;
    description?: string;
    /** Allows to specifiy how to handle certain input parameters, e.g., have to be provided by the user upon invocation, use constant values, or fetch value from another property of the DT. */
    inputArgumentTypes?: { [key: string]: ArgumentMapping; };
    /** Allows to specifiy how to handle certain output parameters, e.g., to be returned to the user or write value to another property of the DT. */
    outputArgumentTypes?: { [key: string]: ArgumentMapping; };
    /** Input parameters that have to be provided by the user upon invocation. */
    actualInputParameters?: SubmodelElement[];
    /** Output parameters that will be returned to the user after invocation. */
    actualOutputParameters?: SubmodelElement[];

    [key: string]: any;
}

/** Output parameters that will be returned to the user after invocation. */
export class SubmodelElement implements ISubmodelElement {
    embeddedDataSpecifications?: EmbeddedDataSpecification[];
    displayName?: LangStringNameType[];
    description?: LangStringTextType[];
    idShort?: string;
    category?: string;
    extensions?: Extension[];
    supplementalSemanticIds?: Reference[];
    semanticId?: Reference;
    qualifiers?: Qualifier[];

    [key: string]: any;

    constructor(data?: ISubmodelElement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["embeddedDataSpecifications"])) {
                this.embeddedDataSpecifications = [] as any;
                for (let item of _data["embeddedDataSpecifications"])
                    this.embeddedDataSpecifications!.push(EmbeddedDataSpecification.fromJS(item));
            }
            if (Array.isArray(_data["displayName"])) {
                this.displayName = [] as any;
                for (let item of _data["displayName"])
                    this.displayName!.push(LangStringNameType.fromJS(item));
            }
            if (Array.isArray(_data["description"])) {
                this.description = [] as any;
                for (let item of _data["description"])
                    this.description!.push(LangStringTextType.fromJS(item));
            }
            this.idShort = _data["idShort"];
            this.category = _data["category"];
            if (Array.isArray(_data["extensions"])) {
                this.extensions = [] as any;
                for (let item of _data["extensions"])
                    this.extensions!.push(Extension.fromJS(item));
            }
            if (Array.isArray(_data["supplementalSemanticIds"])) {
                this.supplementalSemanticIds = [] as any;
                for (let item of _data["supplementalSemanticIds"])
                    this.supplementalSemanticIds!.push(Reference.fromJS(item));
            }
            this.semanticId = _data["semanticId"] ? Reference.fromJS(_data["semanticId"]) : undefined as any;
            if (Array.isArray(_data["qualifiers"])) {
                this.qualifiers = [] as any;
                for (let item of _data["qualifiers"])
                    this.qualifiers!.push(Qualifier.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubmodelElement {
        data = typeof data === 'object' ? data : {};
        let result = new SubmodelElement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.embeddedDataSpecifications)) {
            data["embeddedDataSpecifications"] = [];
            for (let item of this.embeddedDataSpecifications)
                data["embeddedDataSpecifications"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.displayName)) {
            data["displayName"] = [];
            for (let item of this.displayName)
                data["displayName"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.description)) {
            data["description"] = [];
            for (let item of this.description)
                data["description"].push(item ? item.toJSON() : undefined as any);
        }
        data["idShort"] = this.idShort;
        data["category"] = this.category;
        if (Array.isArray(this.extensions)) {
            data["extensions"] = [];
            for (let item of this.extensions)
                data["extensions"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.supplementalSemanticIds)) {
            data["supplementalSemanticIds"] = [];
            for (let item of this.supplementalSemanticIds)
                data["supplementalSemanticIds"].push(item ? item.toJSON() : undefined as any);
        }
        data["semanticId"] = this.semanticId ? this.semanticId.toJSON() : undefined as any;
        if (Array.isArray(this.qualifiers)) {
            data["qualifiers"] = [];
            for (let item of this.qualifiers)
                data["qualifiers"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

/** Output parameters that will be returned to the user after invocation. */
export interface ISubmodelElement {
    embeddedDataSpecifications?: EmbeddedDataSpecification[];
    displayName?: LangStringNameType[];
    description?: LangStringTextType[];
    idShort?: string;
    category?: string;
    extensions?: Extension[];
    supplementalSemanticIds?: Reference[];
    semanticId?: Reference;
    qualifiers?: Qualifier[];

    [key: string]: any;
}

export class SmartServiceRequest implements ISmartServiceRequest {
    serviceCatalogId!: string;
    name!: string;
    description?: string;
    inputParameters?: SubmodelElement[];
    outputParameters?: SubmodelElement[];
    /** Allows to change input arguments source from user to constant value or to be fetched from another AAS element */
    inputArgumentTypes?: { [key: string]: ArgumentMapping; };
    /** Allows to change output arguments source from user to constant value or to be written to another AAS element */
    outputArgumentTypes?: { [key: string]: ArgumentMapping; };

    [key: string]: any;

    constructor(data?: ISmartServiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.serviceCatalogId = _data["serviceCatalogId"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["inputParameters"])) {
                this.inputParameters = [] as any;
                for (let item of _data["inputParameters"])
                    this.inputParameters!.push(SubmodelElement.fromJS(item));
            }
            if (Array.isArray(_data["outputParameters"])) {
                this.outputParameters = [] as any;
                for (let item of _data["outputParameters"])
                    this.outputParameters!.push(SubmodelElement.fromJS(item));
            }
            if (_data["inputArgumentTypes"]) {
                this.inputArgumentTypes = {} as any;
                for (let key in _data["inputArgumentTypes"]) {
                    if (_data["inputArgumentTypes"].hasOwnProperty(key))
                        (this.inputArgumentTypes as any)![key] = _data["inputArgumentTypes"][key] ? ArgumentMapping.fromJS(_data["inputArgumentTypes"][key]) : new ArgumentMapping();
                }
            }
            if (_data["outputArgumentTypes"]) {
                this.outputArgumentTypes = {} as any;
                for (let key in _data["outputArgumentTypes"]) {
                    if (_data["outputArgumentTypes"].hasOwnProperty(key))
                        (this.outputArgumentTypes as any)![key] = _data["outputArgumentTypes"][key] ? ArgumentMapping.fromJS(_data["outputArgumentTypes"][key]) : new ArgumentMapping();
                }
            }
        }
    }

    static fromJS(data: any): SmartServiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SmartServiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["serviceCatalogId"] = this.serviceCatalogId;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.inputParameters)) {
            data["inputParameters"] = [];
            for (let item of this.inputParameters)
                data["inputParameters"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.outputParameters)) {
            data["outputParameters"] = [];
            for (let item of this.outputParameters)
                data["outputParameters"].push(item ? item.toJSON() : undefined as any);
        }
        if (this.inputArgumentTypes) {
            data["inputArgumentTypes"] = {};
            for (let key in this.inputArgumentTypes) {
                if (this.inputArgumentTypes.hasOwnProperty(key))
                    (data["inputArgumentTypes"] as any)[key] = this.inputArgumentTypes[key] ? this.inputArgumentTypes[key].toJSON() : undefined as any;
            }
        }
        if (this.outputArgumentTypes) {
            data["outputArgumentTypes"] = {};
            for (let key in this.outputArgumentTypes) {
                if (this.outputArgumentTypes.hasOwnProperty(key))
                    (data["outputArgumentTypes"] as any)[key] = this.outputArgumentTypes[key] ? this.outputArgumentTypes[key].toJSON() : undefined as any;
            }
        }
        return data;
    }
}

export interface ISmartServiceRequest {
    serviceCatalogId: string;
    name: string;
    description?: string;
    inputParameters?: SubmodelElement[];
    outputParameters?: SubmodelElement[];
    /** Allows to change input arguments source from user to constant value or to be fetched from another AAS element */
    inputArgumentTypes?: { [key: string]: ArgumentMapping; };
    /** Allows to change output arguments source from user to constant value or to be written to another AAS element */
    outputArgumentTypes?: { [key: string]: ArgumentMapping; };

    [key: string]: any;
}

export class ModuleDetailsResponse implements IModuleDetailsResponse {
    /** base64-encoded */
    providedModel?: string;
    /** base64-encoded */
    actualModel?: string;

    [key: string]: any;

    constructor(data?: IModuleDetailsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.providedModel = _data["providedModel"];
            this.actualModel = _data["actualModel"];
        }
    }

    static fromJS(data: any): ModuleDetailsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleDetailsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["providedModel"] = this.providedModel;
        data["actualModel"] = this.actualModel;
        return data;
    }
}

export interface IModuleDetailsResponse {
    /** base64-encoded */
    providedModel?: string;
    /** base64-encoded */
    actualModel?: string;

    [key: string]: any;
}

export enum AssetOperationProviderConfigInputValidationMode {
    NONE = "NONE",
    REQUIRE_PRESENT = "REQUIRE_PRESENT",
    REQUIRE_PRESENT_OR_DEFAULT = "REQUIRE_PRESENT_OR_DEFAULT",
}

export enum AssetOperationProviderConfigInoutputValidationMode {
    NONE = "NONE",
    REQUIRE_PRESENT = "REQUIRE_PRESENT",
    REQUIRE_PRESENT_OR_DEFAULT = "REQUIRE_PRESENT_OR_DEFAULT",
}

export enum AssetOperationProviderConfigOutputValidationMode {
    NONE = "NONE",
    REQUIRE_PRESENT = "REQUIRE_PRESENT",
    REQUIRE_PRESENT_OR_DEFAULT = "REQUIRE_PRESENT_OR_DEFAULT",
}

export enum ModuleRequestFormat {
    JSON = "JSON",
    XML = "XML",
    RDF = "RDF",
    JSONLD = "JSONLD",
    AASX = "AASX",
}

export enum ModuleRequestType {
    DOCKER = "DOCKER",
    INTERNAL = "INTERNAL",
}

export enum ArgumentMappingType {
    CONSTANT = "CONSTANT",
    USER = "USER",
    REFERENCE = "REFERENCE",
}

export enum ExtensionValueType {
    ANY_URI = "ANY_URI",
    BASE64BINARY = "BASE64BINARY",
    BOOLEAN = "BOOLEAN",
    BYTE = "BYTE",
    DATE = "DATE",
    DATE_TIME = "DATE_TIME",
    DECIMAL = "DECIMAL",
    DOUBLE = "DOUBLE",
    DURATION = "DURATION",
    FLOAT = "FLOAT",
    GDAY = "GDAY",
    GMONTH = "GMONTH",
    GMONTH_DAY = "GMONTH_DAY",
    GYEAR = "GYEAR",
    GYEAR_MONTH = "GYEAR_MONTH",
    HEX_BINARY = "HEX_BINARY",
    INT = "INT",
    INTEGER = "INTEGER",
    LONG = "LONG",
    NEGATIVE_INTEGER = "NEGATIVE_INTEGER",
    NON_NEGATIVE_INTEGER = "NON_NEGATIVE_INTEGER",
    NON_POSITIVE_INTEGER = "NON_POSITIVE_INTEGER",
    POSITIVE_INTEGER = "POSITIVE_INTEGER",
    SHORT = "SHORT",
    STRING = "STRING",
    TIME = "TIME",
    UNSIGNED_BYTE = "UNSIGNED_BYTE",
    UNSIGNED_INT = "UNSIGNED_INT",
    UNSIGNED_LONG = "UNSIGNED_LONG",
    UNSIGNED_SHORT = "UNSIGNED_SHORT",
}

export enum KeyType {
    ANNOTATED_RELATIONSHIP_ELEMENT = "ANNOTATED_RELATIONSHIP_ELEMENT",
    ASSET_ADMINISTRATION_SHELL = "ASSET_ADMINISTRATION_SHELL",
    BASIC_EVENT_ELEMENT = "BASIC_EVENT_ELEMENT",
    BLOB = "BLOB",
    CAPABILITY = "CAPABILITY",
    CONCEPT_DESCRIPTION = "CONCEPT_DESCRIPTION",
    DATA_ELEMENT = "DATA_ELEMENT",
    ENTITY = "ENTITY",
    EVENT_ELEMENT = "EVENT_ELEMENT",
    FILE = "FILE",
    FRAGMENT_REFERENCE = "FRAGMENT_REFERENCE",
    GLOBAL_REFERENCE = "GLOBAL_REFERENCE",
    IDENTIFIABLE = "IDENTIFIABLE",
    MULTI_LANGUAGE_PROPERTY = "MULTI_LANGUAGE_PROPERTY",
    OPERATION = "OPERATION",
    PROPERTY = "PROPERTY",
    RANGE = "RANGE",
    REFERABLE = "REFERABLE",
    REFERENCE_ELEMENT = "REFERENCE_ELEMENT",
    RELATIONSHIP_ELEMENT = "RELATIONSHIP_ELEMENT",
    SUBMODEL = "SUBMODEL",
    SUBMODEL_ELEMENT = "SUBMODEL_ELEMENT",
    SUBMODEL_ELEMENT_COLLECTION = "SUBMODEL_ELEMENT_COLLECTION",
    SUBMODEL_ELEMENT_LIST = "SUBMODEL_ELEMENT_LIST",
}

export enum QualifierKind {
    CONCEPT_QUALIFIER = "CONCEPT_QUALIFIER",
    TEMPLATE_QUALIFIER = "TEMPLATE_QUALIFIER",
    VALUE_QUALIFIER = "VALUE_QUALIFIER",
}

export enum QualifierValueType {
    ANY_URI = "ANY_URI",
    BASE64BINARY = "BASE64BINARY",
    BOOLEAN = "BOOLEAN",
    BYTE = "BYTE",
    DATE = "DATE",
    DATE_TIME = "DATE_TIME",
    DECIMAL = "DECIMAL",
    DOUBLE = "DOUBLE",
    DURATION = "DURATION",
    FLOAT = "FLOAT",
    GDAY = "GDAY",
    GMONTH = "GMONTH",
    GMONTH_DAY = "GMONTH_DAY",
    GYEAR = "GYEAR",
    GYEAR_MONTH = "GYEAR_MONTH",
    HEX_BINARY = "HEX_BINARY",
    INT = "INT",
    INTEGER = "INTEGER",
    LONG = "LONG",
    NEGATIVE_INTEGER = "NEGATIVE_INTEGER",
    NON_NEGATIVE_INTEGER = "NON_NEGATIVE_INTEGER",
    NON_POSITIVE_INTEGER = "NON_POSITIVE_INTEGER",
    POSITIVE_INTEGER = "POSITIVE_INTEGER",
    SHORT = "SHORT",
    STRING = "STRING",
    TIME = "TIME",
    UNSIGNED_BYTE = "UNSIGNED_BYTE",
    UNSIGNED_INT = "UNSIGNED_INT",
    UNSIGNED_LONG = "UNSIGNED_LONG",
    UNSIGNED_SHORT = "UNSIGNED_SHORT",
}

export enum ReferenceType {
    EXTERNAL_REFERENCE = "EXTERNAL_REFERENCE",
    MODEL_REFERENCE = "MODEL_REFERENCE",
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}
